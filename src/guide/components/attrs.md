---
outline: deep
---

# Прохідні атрибути {#fallthrough-attributes}

> Ця сторінка передбачає, що ви вже прочитали [основи компонентів](/guide/essentials/component-basics). Прочитайте це спочатку, якщо ви новачок у компонентах.

## Наслідування атрибутів {#attribute-inheritance}

Прохідний атрибут — це атрибут або `v-on` слухач подій, який передається компоненту, але не оголошується явно в [реквізитах](./props) або [випромінюваннях](./events.html#declaring-emitted-events) приймаючого компонента. Типовими прикладами цього є атрибути `class`, `style` та `id`.

Коли компонент рендерить один кореневий елемент, прохідні атрибути будуть автоматично додані до атрибутів кореневого елемента. Наприклад, задано компонент `<MyButton>` з таким шаблоном:

```vue-html
<!-- шаблон <MyButton> -->
<button>натиснути</button>
```

І батько, який використовує цей компонент:

```vue-html
<MyButton class="large" />
```

Кінцевий відрендерений DOM буде таким:

```html
<button class="large">натиснути</button>
```

Тут `<MyButton>` не оголосив `class` як прийнятний реквізит. Таким чином, `class` розглядається як прохідний атрибут і автоматично додається до кореневого елемента `<MyButton>`.

### Злиття `class` та `style` {#class-and-style-merging}

Якщо кореневий елемент дочірнього компонента вже має наявні атрибути `class` або `style`, його буде об’єднано зі значеннями `class` і `style`, успадкованими від батьківського. Наприклад, ми змінили шаблон `<MyButton>` у попередньому прикладі на:

```vue-html
<!-- шаблон <MyButton> -->
<button class="btn">натиснути</button>
```

Кінцевий відрендерений DOM буде таким:

```html
<button class="btn large">натиснути</button>
```

### Наслідування слухача `v-on` {#v-on-listener-inheritance}

Те саме правило застосовується до слуховувачів подій `v-on`:

```vue-html
<MyButton @click="onClick" />
```

Слухач `click` буде додано до кореневого елемента `<MyButton>`, тобто власного елемента `<button>`. Натискання саме `<button>` запустить метод `onClick` батьківського компонента. Якщо власний елемент `<button>` вже має `click` слухач, пов'язаний з `v-on`, тоді обидва слухачі будуть активовані.

### Вкладене наслідування компонентів {#nested-component-inheritance}

Наприклад, якщо компонент відображає інший компонент як свій кореневий. Ми переробили `<MyButton>`, щоб відобразити `<BaseButton>` як його кореневий вузол:

```vue-html
<!-- шаблон <MyButton/> який просто відображає інший компонент -->
<BaseButton />
```

Тоді прохідні атрибути, отримані `<MyButton>`, будуть автоматично перенаправлені `<BaseButton>`.

Зауважте, що:

1. Перенаправлені атрибути не включають жодних атрибутів, оголошених як реквізити, або `v-on` слухачів оголошених подій `<MyButton>` — іншими словами, оголошені атрибути та слухачі були "спожиті" `<MyButton>`.

2. Перенаправлені атрибути можуть бути прийняті як реквізити `<BaseButton>`, якщо вони оголошені ним.

## Вимкнення наслідування атрибутів {#disabling-attribute-inheritance}

Якщо ви **не** хочете, щоб компонент автоматично наслідував атрибути, ви можете встановити `inheritAttrs: false` у параметрах компонента.

<div class="composition-api">

Якщо використовується `<script setup>`, то вам потрібно буде оголосити цей параметр за допомогою окремого звичайного блоку `<script>`:

```vue
<script>
// використовувати звичайний <script> для оголошення параметрів
export default {
  inheritAttrs: false
}
</script>

<script setup>
// ...логіка налаштування
</script>
```

</div>

Загальний сценарій вимкнення наслідування атрибутів полягає в тому, що атрибути потрібно застосувати до інших елементів, крім кореневого вузла. Установивши для параметра `inheritAttrs` значення `false`, ви можете отримати повний контроль над тим, де слід застосовувати прохідні атрибути.     
  
Ці прохідні атрибути можна отримати безпосередньо у виразах шаблону як `$attrs`:

```vue-html
<span>Атрибут: {{ $attrs }}</span>
```

Об’єкт `$attrs` включає всі атрибути, які не оголошені параметрами `props` або `emits` компонента (наприклад, `class`, `style`, `v-on` слухачі тощо).

Деякі примітки:

- На відміну від реквізитів, прохідні атрибути зберігають свій початковий регістр у JavaScript, тому до такого атрибута, як `foo-bar`, потрібно звертатися як `$attrs['foo-bar']`.

- Слухач подій `v-on`, як `@click`, буде представлений в об’єкті як функція в `$attrs.onClick`.

Використовуючи наш приклад компонента `<MyButton>` з [попереднього розділу](#attribute-inheritance) – іноді нам може знадобитися обернути фактичний елемент `<button>` додатковим `<div>` для стилізації:

```vue-html
<div class="btn-wrapper">
  <button class="btn">натиснути</button>
</div>
```

Ми хочемо, щоб усі прохідні атрибути, такі як `class` і `v-on` слухачі, застосовувалися до внутрішнього `<button>`, а не до зовнішнього `<div>`. Ми можемо досягти цього за допомогою `inheritAttrs: false` та `v-bind="$attrs"`:

```vue-html{2}
<div class="btn-wrapper">
  <button class="btn" v-bind="$attrs">натиснути</button>
</div>
```

Пам’ятайте, що [`v-bind` без аргументу](/guide/essentials/template-syntax.html#dynamically-binding-multiple-attributes) прив’язує всі властивості об’єкта як атрибути цільового елемента.

## Наслідування атрибутів на кількох кореневих вузлах {#attribute-inheritance-on-multiple-root-nodes}

На відміну від компонентів з одним кореневим вузлом, компоненти з кількома кореневими вузлами не мають автоматичної поведінки проходу атрибутів. Якщо `$attrs` не прив'язані явно, буде видано попередження під час виконання.

```vue-html
<CustomLayout id="custom-layout" @click="changeValue" />
```

Якщо `<CustomLayout>` має наступний багатокореневий шаблон, виникне попередження, оскільки Vue не може бути впевнений, де застосувати прохідні атрибути:

```vue-html
<header>...</header>
<main>...</main>
<footer>...</footer>
```

Попередження зникне, якщо `$attrs` прив'язано явно:

```vue-html{2}
<header>...</header>
<main v-bind="$attrs">...</main>
<footer>...</footer>
```

## Доступ до прохідних атрибутів in JavaScript  {#accessing-fallthrough-attributes-in-java-script}

<div class="composition-api">

За потреби ви можете отримати доступ до прохідних атрибутів в `<script setup>` за допомогою API `useAttrs()`:

```vue
<script setup>
import { useAttrs } from 'vue'

const attrs = useAttrs()
</script>
```

Без використання `<script setup>`, `attrs` буде представлено як властивість контексту `setup()`:

```js
export default {
  setup(props, ctx) {
    // прохідні атрибути представлені як ctx.attrs
    console.log(ctx.attrs)
  }
}
```

Зауважте, що хоча об’єкт `attrs` тут завжди відображає останні прохідні атрибути, він не є реактивним (з причин продуктивності). Ви не можете використовувати спостерігачі для спостереження за його змінами. Якщо вам потрібна реактивність, використовуйте реквізити. Крім того, ви можете використовувати `onUpdated()`, щоб виконувати побічні ефекти з останніми `attrs` під час кожного оновлення.

</div>

<div class="options-api">

За потреби ви можете отримати доступ до прохідних атрибутів компонента через властивість екземпляра `$attrs`:

```js
export default {
  created() {
    console.log(this.$attrs)
  }
}
```

</div>
